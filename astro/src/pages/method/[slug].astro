---
import '@styles/topic-page.css'
import type {SanityDocument} from '@sanity/client'
import {loadQuery} from '@sanity/lib/load-query'
import PortableText from '@components/PortableText.astro'
import Layout from '@layouts/Layout.astro'
import Hero from '@components/Hero.astro'
import Card from '@components/Card.astro'
import CardExt from '@components/CardExt.astro'
import {METHODS_QUERY} from '@sanity/sanity.queries'
import type {HeroImage, METHODS_QUERYResult} from 'sanity.types'

const {params} = Astro

// Queue up one page for each Method
export async function getStaticPaths() {
  const {data: methods} = await loadQuery<SanityDocument[]>({
    query: `*[_type == "method"]`,
  })

  return methods.map(({slug}) => {
    return {
      params: {
        slug: slug.current,
      },
    }
  })
}

// Get shared output from KG
async function getSharedOutput() {
  const kgData = await fetch('https://fuseki.uxmethods.org/ds/query', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/sparql-query',
      Accept: 'application/sparql-results+json',
      // Authorization: 'Basic ' + btoa(process.env.KG_AUTH),
      // ðŸš¨ Replace after testing
      Authorization: 'Basic ' + btoa('andyfitz:uxm25'),
    },
    // Narrow this to the present method? Or at least limit return.
    body: `
    PREFIX : <https://uxmethods.org/>
    PREFIX uxmo: <https://uxmethods.org/ontology/>
    
    SELECT ?origin ?destination (COUNT(?output) AS ?sharedOutputCount)
    (GROUP_CONCAT(DISTINCT ?output; SEPARATOR=",") AS ?sharedOutput)
    WHERE {
      ?origin uxmo:hasOutput ?output.
      ?destination uxmo:hasInput ?output.
      }
      GROUP BY ?origin ?destination
      ORDER BY DESC(?sharedOutputCount)
      `,
  })

  if (!kgData.ok) {
    throw new Error(`Failed to fetch from KG: HTTP error! status: ${kgData.status}`)
  }

  const data = await kgData.json()
  return transformKgData(data)
}

// Transform SPARQL results for mapping
function transformKgData(kgData: any) {
  return kgData.results.bindings.map((binding: any) => ({
    origin: binding.origin.value,
    destination: binding.destination.value,
    sharedOutputCount: parseInt(binding.sharedOutputCount.value),
    sharedOutput: binding.sharedOutput.value.split(','),
  }))
}

// Fetch method and KG data concurrently
const [{data: method}, kgData] = await Promise.all([
  loadQuery<METHODS_QUERYResult>({
    query: METHODS_QUERY,
    params,
  }),
  getSharedOutput(),
])

const methodPreviews = method?.methodPreviews

// Map method previews to KG data
function mapMethods(method: any, methodPreviews: any, kgData: any): any {
  // const preparedMethods = methods.map((method) => {
  // Filter and assign methods preview list to previous methods
  // TODO: verify that mapping is weighted to prioritize strongest connections
  // console.log('Methodl URI', method.uri)
  // console.log('Methodl Preview', methodPreviews.slice(0, 2))
  const previousMethods = methodPreviews.filter((methodPreview: any) => {
    return kgData.some((relationship: any) => {
      return relationship.destination === method.uri && relationship.origin === methodPreview.uri
    })
  })
  // Filter and assign methods preview list to next methods
  const continueMethods = methodPreviews.filter((methodPreview: any) => {
    return kgData.some((relationship: any) => {
      return relationship.origin === method.uri && relationship.destination === methodPreview.uri
    })
  })
  return [previousMethods, continueMethods]
}

const [previousMethods, continueMethods] = mapMethods(method, methodPreviews, kgData)

// console.log('Previous', previousMethods)
// console.log('Continue', continueMethods)

const heroImage = method?.heroImage as HeroImage

if (!method) {
  Astro.response.status = 404
  throw new Error('Not found - template rendering error')
}
---

<Layout data={method.footer} pageTitle={method.title}>
  <!-- <pre>{JSON.stringify(params, null, 2)}</pre> -->
  <article class="method">
    <section class="overview">
      <Hero image={heroImage} />
      <div class="header">
        <h1>
          <span>{method.title}</span>
          <span>Method</span>
        </h1>
      </div>
      <div class="description">
        <PortableText portableText={method.overview} />
      </div>
    </section>
    {
      previousMethods.length > 0 && (
        <section>
          <h2>Preparation</h2>
          <p>
            {method.title} is often more effective when it is informed by these complementary
            methods.
          </p>
          <ul class="grid">
            {previousMethods.slice(0,6).map((resource: any) => (
              <Card content={resource} size={"compact-card"}/>
            ))}
          </ul>
        </section>
      )
    }
    <section class="details">
      <div class="steps">
        <h2>Steps</h2>
        <PortableText portableText={method.steps} />
      </div>
      <div class="outcomes">
        <h2>Outcomes</h2>
        <p>{method.title} typically produces insight and solutions focused on these areas:</p>
        <ul>
          {
            method.outcomes &&
              method.outcomes.map((outcome) => (
                <li>
                  <h3>{outcome.prefLabel}</h3>
                  <p>{outcome.definition}</p>
                </li>
              ))
          }
        </ul>
      </div>
    </section>
    {
      method.resources.length > 0 && (
        <section>
          <h2>Resources</h2>
          <ul class="grid">
            {method.resources.slice(0,6).map((resource: any) => (
              <CardExt content={resource} />
            ))}
          </ul>
        </section>
      )
    }
    {
      continueMethods.length > 0 && (
        <section>
          <h2>Next Steps</h2>
          <ul class="grid">
            {continueMethods.slice(0,6).map((resource: any) => (
              <Card content={resource} />
            ))}
          </ul>
        </section>
      )
    }
  </article>
</Layout>

<style>
  /* ðŸ‘‡Citations appear to have gone missing â€” investigate */
  .citation {
    font-size: 70%;
    vertical-align: top;
    padding-left: 0.25rem;
  }
  .details {
    .steps {
      ol {
        padding-left: 1.5rem;
      }
      li {
        margin-bottom: 0.75rem;
        line-height: 1.5;
      }
    }
    .outcomes {
      ul {
        list-style: none;
        padding-inline-start: 1.3rem;
        p {
          margin-top: 0;
        }
      }
    }
    @media (min-width: 800px) {
      display: flex;
      .steps {
        width: 70%;
        ol {
          padding-right: 6rem;
        }
        p {
          padding-right: 3rem;
        }
      }
      .outcomes {
        width: 30%;
        ul {
          padding-inline-start: 0;
        }
      }
    }
  }
</style>
