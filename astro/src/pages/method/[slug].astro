---
import "@styles/topic-page.css";
import type { SanityDocument } from "@sanity/client";
import { loadQuery } from "@sanity/lib/load-query";
import PortableText from "@components/PortableText.astro";
import Layout from "@layouts/Layout.astro";
import Hero from "@components/Hero.astro";
import Card from "@components/Card.astro";
import CardExt from "@components/CardExt.astro";
import { METHODS_QUERY } from "@sanity/sanity.queries";
import type { HeroImage, METHODS_QUERYResult } from "sanity.types";
import type { FooterData } from "@components/Footer.astro";
import { urlForImage } from "@sanity/lib/url-for-image";

const KG_AUTH = import.meta.env.KG_AUTH;

const { params } = Astro;

// Queue up one page for each Method
export async function getStaticPaths() {
  const { data: methods } = await loadQuery<SanityDocument[]>({
    query: `*[_type == "method"]`,
  });

  return methods.map(({ slug }) => {
    return {
      params: {
        slug: slug.current,
      },
    };
  });
}

// Get shared output from KG
async function getSharedOutput() {
  const kgData = await fetch("https://fuseki.uxmethods.org/ds/query", {
    method: "POST",
    headers: {
      "Content-Type": "application/sparql-query",
      Accept: "application/sparql-results+json",
      // ðŸš¨ Change after testing â€” it's been committed to the repo
      Authorization: "Basic " + btoa(KG_AUTH),
    },
    // Narrow this to the present method? Or at least limit return.
    body: `
    PREFIX : <https://uxmethods.org/>
    PREFIX uxmo: <https://uxmethods.org/ontology/>
    
    SELECT ?origin ?destination (COUNT(?output) AS ?sharedOutputCount)
    (GROUP_CONCAT(DISTINCT ?output; SEPARATOR=",") AS ?sharedOutput)
    WHERE {
      ?origin uxmo:hasOutput ?output.
      ?destination uxmo:hasInput ?output.
      }
      GROUP BY ?origin ?destination
      ORDER BY DESC(?sharedOutputCount)
      `,
  });

  if (!kgData.ok) {
    throw new Error(
      `Failed to fetch from KG: HTTP error! status: ${kgData.status}`,
    );
  }

  const data = await kgData.json();
  return transformKgData(data);
}

// Transform SPARQL results for mapping
function transformKgData(kgData: any) {
  return kgData.results.bindings.map((binding: any) => ({
    origin: binding.origin.value,
    destination: binding.destination.value,
    sharedOutputCount: parseInt(binding.sharedOutputCount.value),
    sharedOutput: binding.sharedOutput.value.split(","),
  }));
}

// Fetch method and KG data concurrently
const [{ data: method }, kgData] = await Promise.all([
  loadQuery<METHODS_QUERYResult>({
    query: METHODS_QUERY,
    params,
  }),
  getSharedOutput(),
]);

const methodPreviews = method?.methodPreviews;

// Map method previews to KG data
function mapMethods(method: any, methodPreviews: any, kgData: any): any {
  // const preparedMethods = methods.map((method) => {
  // Filter and assign methods preview list to previous methods
  // â˜‘ï¸ TODO: verify that mapping is weighted to prioritize strongest connections
  const previousMethods = methodPreviews.filter((methodPreview: any) => {
    return kgData.some((relationship: any) => {
      return (
        relationship.destination === method.uri &&
        relationship.origin === methodPreview.uri
      );
    });
  });
  // Filter and assign methods preview list to next methods
  const continueMethods = methodPreviews.filter((methodPreview: any) => {
    return kgData.some((relationship: any) => {
      return (
        relationship.origin === method.uri &&
        relationship.destination === methodPreview.uri
      );
    });
  });
  return [previousMethods, continueMethods];
}

const [previousMethods, continueMethods] = mapMethods(
  method,
  methodPreviews,
  kgData,
);
const heroImage = method?.heroImage as HeroImage;

// Optional JSON-LD keys:
// const optionalLd = {
//   "keyOne": "value one",
//   "KeyTwo": "value two",
// }

if (!method) {
  Astro.response.status = 404;
  throw new Error("Not found - template rendering error");
}
const footerData: FooterData | null = method.footer
  ? {
      overview: (method.footer.overview ?? []) as FooterData["overview"],
      colophon: (method.footer.colophon ?? []) as FooterData["colophon"],
      credits: (method.footer.credits ?? []) as FooterData["credits"],
    }
  : null;
---

<Layout data={footerData} pageTitle={method.title}>
  <script
    slot="json-ld"
    type="application/ld+json"
    set:html={JSON.stringify(
      {
        // â˜‘ï¸ TO DO: convert this to https://schema.org/HowTo
        "@context": "https://schema.org",
        "@type": "Article",
        url: method.uri,
        headline: method.title,
        description: method.metaDescription,
        datePublished: method.dateStamps?.createdAt,
        dateModified:
          method.dateStamps?.revisedAt || method.dateStamps?.createdAt,
        image: {
          "@type": "ImageObject",
          inLanguage: "en-US",
          url: urlForImage(heroImage).url(),
        },
        // ...optionalLd
      },
      null,
      2,
    )}
  />

  <!-- <pre>{JSON.stringify(params, null, 2)}</pre> -->
  <article class="method">
    <section class="overview">
      <Hero image={heroImage} />
      <div class="header">
        <h1>
          <span>{method.title}</span>
          <span>Method</span>
        </h1>
      </div>
      <div class="description">
        <PortableText portableText={method.overview} />
      </div>
    </section>
    {
      previousMethods.length > 0 && (
        <section>
          <h2>Preparation</h2>
          <p>
            {method.title} is often more effective when it is informed by these
            complementary methods.
          </p>
          <ul class="grid">
            {previousMethods.slice(0, 6).map((resource: any) => (
              <Card content={resource} size={"compact-card"} />
            ))}
          </ul>
        </section>
      )
    }
    <section class="details">
      <div class="steps">
        <h2>Steps</h2>
        <PortableText portableText={method.steps} />
      </div>
      <div class="outcomes">
        <h2>Outcomes</h2>
        <p>
          {method.title} typically produces insight and solutions focused on these
          areas:
        </p>
        <ul>
          {
            method.outcomes &&
              method.outcomes.map((outcome) => (
                <li>
                  <h3>{outcome.prefLabel}</h3>
                  <p>{outcome.definition}</p>
                </li>
              ))
          }
        </ul>
      </div>
    </section>
    {
      method.resources.length > 0 && (
        <section>
          <h2>Resources</h2>
          <ul class="grid">
            {method.resources.slice(0, 6).map((resource: any) => (
              <CardExt content={resource} />
            ))}
          </ul>
        </section>
      )
    }
    {
      continueMethods.length > 0 && (
        <section>
          <h2>Next Steps</h2>
          <ul class="grid">
            {continueMethods.slice(0, 6).map((resource: any) => (
              <Card content={resource} />
            ))}
          </ul>
        </section>
      )
    }
    <section class="references">
      {
        method?.stepSources && method.stepSources.length > 0 && (
          <>
            <h2>References</h2>
            <ol>
              {method.stepSources.map((source: any) => (
                <li class="source-citation">
                  <a href={source.source}>{source.name}</a>
                </li>
              ))}
            </ol>
          </>
        )
      }
      <p class="datestamp">
        {method.title} Method details last edited on {
          method?.dateStamps?.createdAt
        }
      </p>
    </section>
  </article>
</Layout>

<style>
  .method {
    ol {
      padding-left: 1.5rem;
    }
    /* ðŸ‘‡Citations appear to have gone missing â€” investigate */
    .citation {
      font-size: 70%;
      vertical-align: top;
      padding-left: 0.25rem;
    }
    .references {
      font-size: 90%;
      margin-bottom: 0;
      @media (min-width: 1180px) {
        padding: 1rem 0 2rem;
      }
      h2 {
        font-size: 1.5rem;
        border-top: 1px solid var(--light-gray-text);
        padding-top: 0.5rem;
        @media (min-width: 600px) {
          width: 50%;
        }
        @media (min-width: 1000px) {
          width: 33%;
        }
      }
      p {
        padding-top: 1rem;
        font-style: italic;
      }

      li.source-citation {
        margin-bottom: 0.75rem;
        line-height: 1.5;
        @media (min-width: 800px) {
          margin-bottom: 0;
        }
      }
      svg {
        position: relative;
        top: 2px;
        padding-left: 0.25rem;
      }
    }
    .details {
      .steps {
        li {
          margin-bottom: 0.75rem;
          line-height: 1.5;
        }
      }
      .outcomes {
        ul {
          list-style: none;
          padding-inline-start: 1.3rem;
          p {
            margin-top: 0;
          }
        }
      }
      @media (min-width: 800px) {
        display: flex;
        .steps {
          width: 70%;
          ol {
            padding-right: 6rem;
          }
          p {
            padding-right: 3rem;
          }
        }
        .outcomes {
          width: 30%;
          ul {
            padding-inline-start: 0;
          }
        }
      }
    }
  }
</style>
